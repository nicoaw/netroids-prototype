// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Net.proto

#ifndef PROTOBUF_Net_2eproto__INCLUDED
#define PROTOBUF_Net_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace net {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Net_2eproto();
void protobuf_AssignDesc_Net_2eproto();
void protobuf_ShutdownFile_Net_2eproto();

class Input;
class State;
class Move;
class PacketBase;
class PacketSpawn;
class PacketInput;
class PacketSync;

enum PacketType {
  SPAWN = 1,
  INPUT = 2,
  SYNC = 3
};
bool PacketType_IsValid(int value);
const PacketType PacketType_MIN = SPAWN;
const PacketType PacketType_MAX = SYNC;
const int PacketType_ARRAYSIZE = PacketType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PacketType_descriptor();
inline const ::std::string& PacketType_Name(PacketType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PacketType_descriptor(), value);
}
inline bool PacketType_Parse(
    const ::std::string& name, PacketType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PacketType>(
    PacketType_descriptor(), name, value);
}
// ===================================================================

class Input : public ::google::protobuf::Message {
 public:
  Input();
  virtual ~Input();

  Input(const Input& from);

  inline Input& operator=(const Input& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Input& default_instance();

  void Swap(Input* other);

  // implements Message ----------------------------------------------

  Input* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Input& from);
  void MergeFrom(const Input& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool forward = 1;
  inline bool has_forward() const;
  inline void clear_forward();
  static const int kForwardFieldNumber = 1;
  inline bool forward() const;
  inline void set_forward(bool value);

  // required bool left = 2;
  inline bool has_left() const;
  inline void clear_left();
  static const int kLeftFieldNumber = 2;
  inline bool left() const;
  inline void set_left(bool value);

  // required bool right = 3;
  inline bool has_right() const;
  inline void clear_right();
  static const int kRightFieldNumber = 3;
  inline bool right() const;
  inline void set_right(bool value);

  // @@protoc_insertion_point(class_scope:net.Input)
 private:
  inline void set_has_forward();
  inline void clear_has_forward();
  inline void set_has_left();
  inline void clear_has_left();
  inline void set_has_right();
  inline void clear_has_right();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  bool forward_;
  bool left_;
  bool right_;
  friend void  protobuf_AddDesc_Net_2eproto();
  friend void protobuf_AssignDesc_Net_2eproto();
  friend void protobuf_ShutdownFile_Net_2eproto();

  void InitAsDefaultInstance();
  static Input* default_instance_;
};
// -------------------------------------------------------------------

class State : public ::google::protobuf::Message {
 public:
  State();
  virtual ~State();

  State(const State& from);

  inline State& operator=(const State& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const State& default_instance();

  void Swap(State* other);

  // implements Message ----------------------------------------------

  State* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const State& from);
  void MergeFrom(const State& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float position_x = 1;
  inline bool has_position_x() const;
  inline void clear_position_x();
  static const int kPositionXFieldNumber = 1;
  inline float position_x() const;
  inline void set_position_x(float value);

  // required float position_y = 2;
  inline bool has_position_y() const;
  inline void clear_position_y();
  static const int kPositionYFieldNumber = 2;
  inline float position_y() const;
  inline void set_position_y(float value);

  // required float angle = 3;
  inline bool has_angle() const;
  inline void clear_angle();
  static const int kAngleFieldNumber = 3;
  inline float angle() const;
  inline void set_angle(float value);

  // required float velocity_x = 7;
  inline bool has_velocity_x() const;
  inline void clear_velocity_x();
  static const int kVelocityXFieldNumber = 7;
  inline float velocity_x() const;
  inline void set_velocity_x(float value);

  // required float velocity_y = 8;
  inline bool has_velocity_y() const;
  inline void clear_velocity_y();
  static const int kVelocityYFieldNumber = 8;
  inline float velocity_y() const;
  inline void set_velocity_y(float value);

  // required float angular_velocity = 9;
  inline bool has_angular_velocity() const;
  inline void clear_angular_velocity();
  static const int kAngularVelocityFieldNumber = 9;
  inline float angular_velocity() const;
  inline void set_angular_velocity(float value);

  // required float scale = 10;
  inline bool has_scale() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 10;
  inline float scale() const;
  inline void set_scale(float value);

  // required float mass = 11;
  inline bool has_mass() const;
  inline void clear_mass();
  static const int kMassFieldNumber = 11;
  inline float mass() const;
  inline void set_mass(float value);

  // required float inertia_tensor = 12;
  inline bool has_inertia_tensor() const;
  inline void clear_inertia_tensor();
  static const int kInertiaTensorFieldNumber = 12;
  inline float inertia_tensor() const;
  inline void set_inertia_tensor(float value);

  // @@protoc_insertion_point(class_scope:net.State)
 private:
  inline void set_has_position_x();
  inline void clear_has_position_x();
  inline void set_has_position_y();
  inline void clear_has_position_y();
  inline void set_has_angle();
  inline void clear_has_angle();
  inline void set_has_velocity_x();
  inline void clear_has_velocity_x();
  inline void set_has_velocity_y();
  inline void clear_has_velocity_y();
  inline void set_has_angular_velocity();
  inline void clear_has_angular_velocity();
  inline void set_has_scale();
  inline void clear_has_scale();
  inline void set_has_mass();
  inline void clear_has_mass();
  inline void set_has_inertia_tensor();
  inline void clear_has_inertia_tensor();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float position_x_;
  float position_y_;
  float angle_;
  float velocity_x_;
  float velocity_y_;
  float angular_velocity_;
  float scale_;
  float mass_;
  float inertia_tensor_;
  friend void  protobuf_AddDesc_Net_2eproto();
  friend void protobuf_AssignDesc_Net_2eproto();
  friend void protobuf_ShutdownFile_Net_2eproto();

  void InitAsDefaultInstance();
  static State* default_instance_;
};
// -------------------------------------------------------------------

class Move : public ::google::protobuf::Message {
 public:
  Move();
  virtual ~Move();

  Move(const Move& from);

  inline Move& operator=(const Move& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Move& default_instance();

  void Swap(Move* other);

  // implements Message ----------------------------------------------

  Move* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Move& from);
  void MergeFrom(const Move& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // required .net.Input input = 2;
  inline bool has_input() const;
  inline void clear_input();
  static const int kInputFieldNumber = 2;
  inline const ::net::Input& input() const;
  inline ::net::Input* mutable_input();
  inline ::net::Input* release_input();
  inline void set_allocated_input(::net::Input* input);

  // required .net.State state = 3;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 3;
  inline const ::net::State& state() const;
  inline ::net::State* mutable_state();
  inline ::net::State* release_state();
  inline void set_allocated_state(::net::State* state);

  // @@protoc_insertion_point(class_scope:net.Move)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_input();
  inline void clear_has_input();
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::net::Input* input_;
  ::net::State* state_;
  ::google::protobuf::uint32 time_;
  friend void  protobuf_AddDesc_Net_2eproto();
  friend void protobuf_AssignDesc_Net_2eproto();
  friend void protobuf_ShutdownFile_Net_2eproto();

  void InitAsDefaultInstance();
  static Move* default_instance_;
};
// -------------------------------------------------------------------

class PacketBase : public ::google::protobuf::Message {
 public:
  PacketBase();
  virtual ~PacketBase();

  PacketBase(const PacketBase& from);

  inline PacketBase& operator=(const PacketBase& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PacketBase& default_instance();

  void Swap(PacketBase* other);

  // implements Message ----------------------------------------------

  PacketBase* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PacketBase& from);
  void MergeFrom(const PacketBase& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .net.PacketType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::net::PacketType type() const;
  inline void set_type(::net::PacketType value);

  // required bytes data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:net.PacketBase)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* data_;
  int type_;
  friend void  protobuf_AddDesc_Net_2eproto();
  friend void protobuf_AssignDesc_Net_2eproto();
  friend void protobuf_ShutdownFile_Net_2eproto();

  void InitAsDefaultInstance();
  static PacketBase* default_instance_;
};
// -------------------------------------------------------------------

class PacketSpawn : public ::google::protobuf::Message {
 public:
  PacketSpawn();
  virtual ~PacketSpawn();

  PacketSpawn(const PacketSpawn& from);

  inline PacketSpawn& operator=(const PacketSpawn& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PacketSpawn& default_instance();

  void Swap(PacketSpawn* other);

  // implements Message ----------------------------------------------

  PacketSpawn* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PacketSpawn& from);
  void MergeFrom(const PacketSpawn& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required uint32 time = 2;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // required .net.State state = 3;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 3;
  inline const ::net::State& state() const;
  inline ::net::State* mutable_state();
  inline ::net::State* release_state();
  inline void set_allocated_state(::net::State* state);

  // @@protoc_insertion_point(class_scope:net.PacketSpawn)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 time_;
  ::net::State* state_;
  friend void  protobuf_AddDesc_Net_2eproto();
  friend void protobuf_AssignDesc_Net_2eproto();
  friend void protobuf_ShutdownFile_Net_2eproto();

  void InitAsDefaultInstance();
  static PacketSpawn* default_instance_;
};
// -------------------------------------------------------------------

class PacketInput : public ::google::protobuf::Message {
 public:
  PacketInput();
  virtual ~PacketInput();

  PacketInput(const PacketInput& from);

  inline PacketInput& operator=(const PacketInput& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PacketInput& default_instance();

  void Swap(PacketInput* other);

  // implements Message ----------------------------------------------

  PacketInput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PacketInput& from);
  void MergeFrom(const PacketInput& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // required .net.Input input = 2;
  inline bool has_input() const;
  inline void clear_input();
  static const int kInputFieldNumber = 2;
  inline const ::net::Input& input() const;
  inline ::net::Input* mutable_input();
  inline ::net::Input* release_input();
  inline void set_allocated_input(::net::Input* input);

  // repeated .net.Move important_moves = 3;
  inline int important_moves_size() const;
  inline void clear_important_moves();
  static const int kImportantMovesFieldNumber = 3;
  inline const ::net::Move& important_moves(int index) const;
  inline ::net::Move* mutable_important_moves(int index);
  inline ::net::Move* add_important_moves();
  inline const ::google::protobuf::RepeatedPtrField< ::net::Move >&
      important_moves() const;
  inline ::google::protobuf::RepeatedPtrField< ::net::Move >*
      mutable_important_moves();

  // @@protoc_insertion_point(class_scope:net.PacketInput)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_input();
  inline void clear_has_input();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::net::Input* input_;
  ::google::protobuf::RepeatedPtrField< ::net::Move > important_moves_;
  ::google::protobuf::uint32 time_;
  friend void  protobuf_AddDesc_Net_2eproto();
  friend void protobuf_AssignDesc_Net_2eproto();
  friend void protobuf_ShutdownFile_Net_2eproto();

  void InitAsDefaultInstance();
  static PacketInput* default_instance_;
};
// -------------------------------------------------------------------

class PacketSync : public ::google::protobuf::Message {
 public:
  PacketSync();
  virtual ~PacketSync();

  PacketSync(const PacketSync& from);

  inline PacketSync& operator=(const PacketSync& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PacketSync& default_instance();

  void Swap(PacketSync* other);

  // implements Message ----------------------------------------------

  PacketSync* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PacketSync& from);
  void MergeFrom(const PacketSync& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required uint32 time = 2;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // required .net.State state = 3;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 3;
  inline const ::net::State& state() const;
  inline ::net::State* mutable_state();
  inline ::net::State* release_state();
  inline void set_allocated_state(::net::State* state);

  // required .net.Input input = 4;
  inline bool has_input() const;
  inline void clear_input();
  static const int kInputFieldNumber = 4;
  inline const ::net::Input& input() const;
  inline ::net::Input* mutable_input();
  inline ::net::Input* release_input();
  inline void set_allocated_input(::net::Input* input);

  // @@protoc_insertion_point(class_scope:net.PacketSync)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_input();
  inline void clear_has_input();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 time_;
  ::net::State* state_;
  ::net::Input* input_;
  friend void  protobuf_AddDesc_Net_2eproto();
  friend void protobuf_AssignDesc_Net_2eproto();
  friend void protobuf_ShutdownFile_Net_2eproto();

  void InitAsDefaultInstance();
  static PacketSync* default_instance_;
};
// ===================================================================


// ===================================================================

// Input

// required bool forward = 1;
inline bool Input::has_forward() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Input::set_has_forward() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Input::clear_has_forward() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Input::clear_forward() {
  forward_ = false;
  clear_has_forward();
}
inline bool Input::forward() const {
  // @@protoc_insertion_point(field_get:net.Input.forward)
  return forward_;
}
inline void Input::set_forward(bool value) {
  set_has_forward();
  forward_ = value;
  // @@protoc_insertion_point(field_set:net.Input.forward)
}

// required bool left = 2;
inline bool Input::has_left() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Input::set_has_left() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Input::clear_has_left() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Input::clear_left() {
  left_ = false;
  clear_has_left();
}
inline bool Input::left() const {
  // @@protoc_insertion_point(field_get:net.Input.left)
  return left_;
}
inline void Input::set_left(bool value) {
  set_has_left();
  left_ = value;
  // @@protoc_insertion_point(field_set:net.Input.left)
}

// required bool right = 3;
inline bool Input::has_right() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Input::set_has_right() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Input::clear_has_right() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Input::clear_right() {
  right_ = false;
  clear_has_right();
}
inline bool Input::right() const {
  // @@protoc_insertion_point(field_get:net.Input.right)
  return right_;
}
inline void Input::set_right(bool value) {
  set_has_right();
  right_ = value;
  // @@protoc_insertion_point(field_set:net.Input.right)
}

// -------------------------------------------------------------------

// State

// required float position_x = 1;
inline bool State::has_position_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void State::set_has_position_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void State::clear_has_position_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void State::clear_position_x() {
  position_x_ = 0;
  clear_has_position_x();
}
inline float State::position_x() const {
  // @@protoc_insertion_point(field_get:net.State.position_x)
  return position_x_;
}
inline void State::set_position_x(float value) {
  set_has_position_x();
  position_x_ = value;
  // @@protoc_insertion_point(field_set:net.State.position_x)
}

// required float position_y = 2;
inline bool State::has_position_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void State::set_has_position_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void State::clear_has_position_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void State::clear_position_y() {
  position_y_ = 0;
  clear_has_position_y();
}
inline float State::position_y() const {
  // @@protoc_insertion_point(field_get:net.State.position_y)
  return position_y_;
}
inline void State::set_position_y(float value) {
  set_has_position_y();
  position_y_ = value;
  // @@protoc_insertion_point(field_set:net.State.position_y)
}

// required float angle = 3;
inline bool State::has_angle() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void State::set_has_angle() {
  _has_bits_[0] |= 0x00000004u;
}
inline void State::clear_has_angle() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void State::clear_angle() {
  angle_ = 0;
  clear_has_angle();
}
inline float State::angle() const {
  // @@protoc_insertion_point(field_get:net.State.angle)
  return angle_;
}
inline void State::set_angle(float value) {
  set_has_angle();
  angle_ = value;
  // @@protoc_insertion_point(field_set:net.State.angle)
}

// required float velocity_x = 7;
inline bool State::has_velocity_x() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void State::set_has_velocity_x() {
  _has_bits_[0] |= 0x00000008u;
}
inline void State::clear_has_velocity_x() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void State::clear_velocity_x() {
  velocity_x_ = 0;
  clear_has_velocity_x();
}
inline float State::velocity_x() const {
  // @@protoc_insertion_point(field_get:net.State.velocity_x)
  return velocity_x_;
}
inline void State::set_velocity_x(float value) {
  set_has_velocity_x();
  velocity_x_ = value;
  // @@protoc_insertion_point(field_set:net.State.velocity_x)
}

// required float velocity_y = 8;
inline bool State::has_velocity_y() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void State::set_has_velocity_y() {
  _has_bits_[0] |= 0x00000010u;
}
inline void State::clear_has_velocity_y() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void State::clear_velocity_y() {
  velocity_y_ = 0;
  clear_has_velocity_y();
}
inline float State::velocity_y() const {
  // @@protoc_insertion_point(field_get:net.State.velocity_y)
  return velocity_y_;
}
inline void State::set_velocity_y(float value) {
  set_has_velocity_y();
  velocity_y_ = value;
  // @@protoc_insertion_point(field_set:net.State.velocity_y)
}

// required float angular_velocity = 9;
inline bool State::has_angular_velocity() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void State::set_has_angular_velocity() {
  _has_bits_[0] |= 0x00000020u;
}
inline void State::clear_has_angular_velocity() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void State::clear_angular_velocity() {
  angular_velocity_ = 0;
  clear_has_angular_velocity();
}
inline float State::angular_velocity() const {
  // @@protoc_insertion_point(field_get:net.State.angular_velocity)
  return angular_velocity_;
}
inline void State::set_angular_velocity(float value) {
  set_has_angular_velocity();
  angular_velocity_ = value;
  // @@protoc_insertion_point(field_set:net.State.angular_velocity)
}

// required float scale = 10;
inline bool State::has_scale() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void State::set_has_scale() {
  _has_bits_[0] |= 0x00000040u;
}
inline void State::clear_has_scale() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void State::clear_scale() {
  scale_ = 0;
  clear_has_scale();
}
inline float State::scale() const {
  // @@protoc_insertion_point(field_get:net.State.scale)
  return scale_;
}
inline void State::set_scale(float value) {
  set_has_scale();
  scale_ = value;
  // @@protoc_insertion_point(field_set:net.State.scale)
}

// required float mass = 11;
inline bool State::has_mass() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void State::set_has_mass() {
  _has_bits_[0] |= 0x00000080u;
}
inline void State::clear_has_mass() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void State::clear_mass() {
  mass_ = 0;
  clear_has_mass();
}
inline float State::mass() const {
  // @@protoc_insertion_point(field_get:net.State.mass)
  return mass_;
}
inline void State::set_mass(float value) {
  set_has_mass();
  mass_ = value;
  // @@protoc_insertion_point(field_set:net.State.mass)
}

// required float inertia_tensor = 12;
inline bool State::has_inertia_tensor() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void State::set_has_inertia_tensor() {
  _has_bits_[0] |= 0x00000100u;
}
inline void State::clear_has_inertia_tensor() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void State::clear_inertia_tensor() {
  inertia_tensor_ = 0;
  clear_has_inertia_tensor();
}
inline float State::inertia_tensor() const {
  // @@protoc_insertion_point(field_get:net.State.inertia_tensor)
  return inertia_tensor_;
}
inline void State::set_inertia_tensor(float value) {
  set_has_inertia_tensor();
  inertia_tensor_ = value;
  // @@protoc_insertion_point(field_set:net.State.inertia_tensor)
}

// -------------------------------------------------------------------

// Move

// required uint32 time = 1;
inline bool Move::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Move::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Move::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Move::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 Move::time() const {
  // @@protoc_insertion_point(field_get:net.Move.time)
  return time_;
}
inline void Move::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:net.Move.time)
}

// required .net.Input input = 2;
inline bool Move::has_input() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Move::set_has_input() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Move::clear_has_input() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Move::clear_input() {
  if (input_ != NULL) input_->::net::Input::Clear();
  clear_has_input();
}
inline const ::net::Input& Move::input() const {
  // @@protoc_insertion_point(field_get:net.Move.input)
  return input_ != NULL ? *input_ : *default_instance_->input_;
}
inline ::net::Input* Move::mutable_input() {
  set_has_input();
  if (input_ == NULL) input_ = new ::net::Input;
  // @@protoc_insertion_point(field_mutable:net.Move.input)
  return input_;
}
inline ::net::Input* Move::release_input() {
  clear_has_input();
  ::net::Input* temp = input_;
  input_ = NULL;
  return temp;
}
inline void Move::set_allocated_input(::net::Input* input) {
  delete input_;
  input_ = input;
  if (input) {
    set_has_input();
  } else {
    clear_has_input();
  }
  // @@protoc_insertion_point(field_set_allocated:net.Move.input)
}

// required .net.State state = 3;
inline bool Move::has_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Move::set_has_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Move::clear_has_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Move::clear_state() {
  if (state_ != NULL) state_->::net::State::Clear();
  clear_has_state();
}
inline const ::net::State& Move::state() const {
  // @@protoc_insertion_point(field_get:net.Move.state)
  return state_ != NULL ? *state_ : *default_instance_->state_;
}
inline ::net::State* Move::mutable_state() {
  set_has_state();
  if (state_ == NULL) state_ = new ::net::State;
  // @@protoc_insertion_point(field_mutable:net.Move.state)
  return state_;
}
inline ::net::State* Move::release_state() {
  clear_has_state();
  ::net::State* temp = state_;
  state_ = NULL;
  return temp;
}
inline void Move::set_allocated_state(::net::State* state) {
  delete state_;
  state_ = state;
  if (state) {
    set_has_state();
  } else {
    clear_has_state();
  }
  // @@protoc_insertion_point(field_set_allocated:net.Move.state)
}

// -------------------------------------------------------------------

// PacketBase

// required .net.PacketType type = 1;
inline bool PacketBase::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PacketBase::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PacketBase::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PacketBase::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::net::PacketType PacketBase::type() const {
  // @@protoc_insertion_point(field_get:net.PacketBase.type)
  return static_cast< ::net::PacketType >(type_);
}
inline void PacketBase::set_type(::net::PacketType value) {
  assert(::net::PacketType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:net.PacketBase.type)
}

// required bytes data = 2;
inline bool PacketBase::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PacketBase::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PacketBase::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PacketBase::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& PacketBase::data() const {
  // @@protoc_insertion_point(field_get:net.PacketBase.data)
  return *data_;
}
inline void PacketBase::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:net.PacketBase.data)
}
inline void PacketBase::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:net.PacketBase.data)
}
inline void PacketBase::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:net.PacketBase.data)
}
inline ::std::string* PacketBase::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:net.PacketBase.data)
  return data_;
}
inline ::std::string* PacketBase::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void PacketBase::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:net.PacketBase.data)
}

// -------------------------------------------------------------------

// PacketSpawn

// required uint32 id = 1;
inline bool PacketSpawn::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PacketSpawn::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PacketSpawn::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PacketSpawn::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 PacketSpawn::id() const {
  // @@protoc_insertion_point(field_get:net.PacketSpawn.id)
  return id_;
}
inline void PacketSpawn::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:net.PacketSpawn.id)
}

// required uint32 time = 2;
inline bool PacketSpawn::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PacketSpawn::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PacketSpawn::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PacketSpawn::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 PacketSpawn::time() const {
  // @@protoc_insertion_point(field_get:net.PacketSpawn.time)
  return time_;
}
inline void PacketSpawn::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:net.PacketSpawn.time)
}

// required .net.State state = 3;
inline bool PacketSpawn::has_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PacketSpawn::set_has_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PacketSpawn::clear_has_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PacketSpawn::clear_state() {
  if (state_ != NULL) state_->::net::State::Clear();
  clear_has_state();
}
inline const ::net::State& PacketSpawn::state() const {
  // @@protoc_insertion_point(field_get:net.PacketSpawn.state)
  return state_ != NULL ? *state_ : *default_instance_->state_;
}
inline ::net::State* PacketSpawn::mutable_state() {
  set_has_state();
  if (state_ == NULL) state_ = new ::net::State;
  // @@protoc_insertion_point(field_mutable:net.PacketSpawn.state)
  return state_;
}
inline ::net::State* PacketSpawn::release_state() {
  clear_has_state();
  ::net::State* temp = state_;
  state_ = NULL;
  return temp;
}
inline void PacketSpawn::set_allocated_state(::net::State* state) {
  delete state_;
  state_ = state;
  if (state) {
    set_has_state();
  } else {
    clear_has_state();
  }
  // @@protoc_insertion_point(field_set_allocated:net.PacketSpawn.state)
}

// -------------------------------------------------------------------

// PacketInput

// required uint32 time = 1;
inline bool PacketInput::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PacketInput::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PacketInput::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PacketInput::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 PacketInput::time() const {
  // @@protoc_insertion_point(field_get:net.PacketInput.time)
  return time_;
}
inline void PacketInput::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:net.PacketInput.time)
}

// required .net.Input input = 2;
inline bool PacketInput::has_input() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PacketInput::set_has_input() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PacketInput::clear_has_input() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PacketInput::clear_input() {
  if (input_ != NULL) input_->::net::Input::Clear();
  clear_has_input();
}
inline const ::net::Input& PacketInput::input() const {
  // @@protoc_insertion_point(field_get:net.PacketInput.input)
  return input_ != NULL ? *input_ : *default_instance_->input_;
}
inline ::net::Input* PacketInput::mutable_input() {
  set_has_input();
  if (input_ == NULL) input_ = new ::net::Input;
  // @@protoc_insertion_point(field_mutable:net.PacketInput.input)
  return input_;
}
inline ::net::Input* PacketInput::release_input() {
  clear_has_input();
  ::net::Input* temp = input_;
  input_ = NULL;
  return temp;
}
inline void PacketInput::set_allocated_input(::net::Input* input) {
  delete input_;
  input_ = input;
  if (input) {
    set_has_input();
  } else {
    clear_has_input();
  }
  // @@protoc_insertion_point(field_set_allocated:net.PacketInput.input)
}

// repeated .net.Move important_moves = 3;
inline int PacketInput::important_moves_size() const {
  return important_moves_.size();
}
inline void PacketInput::clear_important_moves() {
  important_moves_.Clear();
}
inline const ::net::Move& PacketInput::important_moves(int index) const {
  // @@protoc_insertion_point(field_get:net.PacketInput.important_moves)
  return important_moves_.Get(index);
}
inline ::net::Move* PacketInput::mutable_important_moves(int index) {
  // @@protoc_insertion_point(field_mutable:net.PacketInput.important_moves)
  return important_moves_.Mutable(index);
}
inline ::net::Move* PacketInput::add_important_moves() {
  // @@protoc_insertion_point(field_add:net.PacketInput.important_moves)
  return important_moves_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::net::Move >&
PacketInput::important_moves() const {
  // @@protoc_insertion_point(field_list:net.PacketInput.important_moves)
  return important_moves_;
}
inline ::google::protobuf::RepeatedPtrField< ::net::Move >*
PacketInput::mutable_important_moves() {
  // @@protoc_insertion_point(field_mutable_list:net.PacketInput.important_moves)
  return &important_moves_;
}

// -------------------------------------------------------------------

// PacketSync

// required uint32 id = 1;
inline bool PacketSync::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PacketSync::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PacketSync::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PacketSync::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 PacketSync::id() const {
  // @@protoc_insertion_point(field_get:net.PacketSync.id)
  return id_;
}
inline void PacketSync::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:net.PacketSync.id)
}

// required uint32 time = 2;
inline bool PacketSync::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PacketSync::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PacketSync::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PacketSync::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 PacketSync::time() const {
  // @@protoc_insertion_point(field_get:net.PacketSync.time)
  return time_;
}
inline void PacketSync::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:net.PacketSync.time)
}

// required .net.State state = 3;
inline bool PacketSync::has_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PacketSync::set_has_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PacketSync::clear_has_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PacketSync::clear_state() {
  if (state_ != NULL) state_->::net::State::Clear();
  clear_has_state();
}
inline const ::net::State& PacketSync::state() const {
  // @@protoc_insertion_point(field_get:net.PacketSync.state)
  return state_ != NULL ? *state_ : *default_instance_->state_;
}
inline ::net::State* PacketSync::mutable_state() {
  set_has_state();
  if (state_ == NULL) state_ = new ::net::State;
  // @@protoc_insertion_point(field_mutable:net.PacketSync.state)
  return state_;
}
inline ::net::State* PacketSync::release_state() {
  clear_has_state();
  ::net::State* temp = state_;
  state_ = NULL;
  return temp;
}
inline void PacketSync::set_allocated_state(::net::State* state) {
  delete state_;
  state_ = state;
  if (state) {
    set_has_state();
  } else {
    clear_has_state();
  }
  // @@protoc_insertion_point(field_set_allocated:net.PacketSync.state)
}

// required .net.Input input = 4;
inline bool PacketSync::has_input() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PacketSync::set_has_input() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PacketSync::clear_has_input() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PacketSync::clear_input() {
  if (input_ != NULL) input_->::net::Input::Clear();
  clear_has_input();
}
inline const ::net::Input& PacketSync::input() const {
  // @@protoc_insertion_point(field_get:net.PacketSync.input)
  return input_ != NULL ? *input_ : *default_instance_->input_;
}
inline ::net::Input* PacketSync::mutable_input() {
  set_has_input();
  if (input_ == NULL) input_ = new ::net::Input;
  // @@protoc_insertion_point(field_mutable:net.PacketSync.input)
  return input_;
}
inline ::net::Input* PacketSync::release_input() {
  clear_has_input();
  ::net::Input* temp = input_;
  input_ = NULL;
  return temp;
}
inline void PacketSync::set_allocated_input(::net::Input* input) {
  delete input_;
  input_ = input;
  if (input) {
    set_has_input();
  } else {
    clear_has_input();
  }
  // @@protoc_insertion_point(field_set_allocated:net.PacketSync.input)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace net

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::net::PacketType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::net::PacketType>() {
  return ::net::PacketType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Net_2eproto__INCLUDED
