// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Net.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "Net.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace net {

namespace {

const ::google::protobuf::Descriptor* Input_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Input_reflection_ = NULL;
const ::google::protobuf::Descriptor* State_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  State_reflection_ = NULL;
const ::google::protobuf::Descriptor* Move_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Move_reflection_ = NULL;
const ::google::protobuf::Descriptor* PacketBase_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PacketBase_reflection_ = NULL;
const ::google::protobuf::Descriptor* PacketSpawn_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PacketSpawn_reflection_ = NULL;
const ::google::protobuf::Descriptor* PacketInput_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PacketInput_reflection_ = NULL;
const ::google::protobuf::Descriptor* PacketSync_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PacketSync_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* PacketType_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_Net_2eproto() {
  protobuf_AddDesc_Net_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "Net.proto");
  GOOGLE_CHECK(file != NULL);
  Input_descriptor_ = file->message_type(0);
  static const int Input_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Input, forward_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Input, left_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Input, right_),
  };
  Input_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Input_descriptor_,
      Input::default_instance_,
      Input_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Input, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Input, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Input));
  State_descriptor_ = file->message_type(1);
  static const int State_offsets_[9] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(State, position_x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(State, position_y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(State, angle_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(State, velocity_x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(State, velocity_y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(State, angular_velocity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(State, scale_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(State, mass_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(State, inertia_tensor_),
  };
  State_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      State_descriptor_,
      State::default_instance_,
      State_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(State, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(State, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(State));
  Move_descriptor_ = file->message_type(2);
  static const int Move_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Move, time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Move, input_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Move, state_),
  };
  Move_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Move_descriptor_,
      Move::default_instance_,
      Move_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Move, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Move, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Move));
  PacketBase_descriptor_ = file->message_type(3);
  static const int PacketBase_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PacketBase, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PacketBase, data_),
  };
  PacketBase_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PacketBase_descriptor_,
      PacketBase::default_instance_,
      PacketBase_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PacketBase, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PacketBase, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PacketBase));
  PacketSpawn_descriptor_ = file->message_type(4);
  static const int PacketSpawn_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PacketSpawn, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PacketSpawn, time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PacketSpawn, state_),
  };
  PacketSpawn_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PacketSpawn_descriptor_,
      PacketSpawn::default_instance_,
      PacketSpawn_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PacketSpawn, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PacketSpawn, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PacketSpawn));
  PacketInput_descriptor_ = file->message_type(5);
  static const int PacketInput_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PacketInput, time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PacketInput, input_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PacketInput, important_moves_),
  };
  PacketInput_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PacketInput_descriptor_,
      PacketInput::default_instance_,
      PacketInput_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PacketInput, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PacketInput, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PacketInput));
  PacketSync_descriptor_ = file->message_type(6);
  static const int PacketSync_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PacketSync, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PacketSync, time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PacketSync, state_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PacketSync, input_),
  };
  PacketSync_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PacketSync_descriptor_,
      PacketSync::default_instance_,
      PacketSync_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PacketSync, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PacketSync, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PacketSync));
  PacketType_descriptor_ = file->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_Net_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Input_descriptor_, &Input::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    State_descriptor_, &State::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Move_descriptor_, &Move::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PacketBase_descriptor_, &PacketBase::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PacketSpawn_descriptor_, &PacketSpawn::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PacketInput_descriptor_, &PacketInput::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PacketSync_descriptor_, &PacketSync::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_Net_2eproto() {
  delete Input::default_instance_;
  delete Input_reflection_;
  delete State::default_instance_;
  delete State_reflection_;
  delete Move::default_instance_;
  delete Move_reflection_;
  delete PacketBase::default_instance_;
  delete PacketBase_reflection_;
  delete PacketSpawn::default_instance_;
  delete PacketSpawn_reflection_;
  delete PacketInput::default_instance_;
  delete PacketInput_reflection_;
  delete PacketSync::default_instance_;
  delete PacketSync_reflection_;
}

void protobuf_AddDesc_Net_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\tNet.proto\022\003net\"5\n\005Input\022\017\n\007forward\030\001 \002"
    "(\010\022\014\n\004left\030\002 \002(\010\022\r\n\005right\030\003 \002(\010\"\265\001\n\005Stat"
    "e\022\022\n\nposition_x\030\001 \002(\002\022\022\n\nposition_y\030\002 \002("
    "\002\022\r\n\005angle\030\003 \002(\002\022\022\n\nvelocity_x\030\007 \002(\002\022\022\n\n"
    "velocity_y\030\010 \002(\002\022\030\n\020angular_velocity\030\t \002"
    "(\002\022\r\n\005scale\030\n \002(\002\022\014\n\004mass\030\013 \002(\002\022\026\n\016inert"
    "ia_tensor\030\014 \002(\002\"J\n\004Move\022\014\n\004time\030\001 \002(\r\022\031\n"
    "\005input\030\002 \002(\0132\n.net.Input\022\031\n\005state\030\003 \002(\0132"
    "\n.net.State\"9\n\nPacketBase\022\035\n\004type\030\001 \002(\0162"
    "\017.net.PacketType\022\014\n\004data\030\002 \002(\014\"B\n\013Packet"
    "Spawn\022\n\n\002id\030\001 \002(\r\022\014\n\004time\030\002 \002(\r\022\031\n\005state"
    "\030\003 \002(\0132\n.net.State\"Z\n\013PacketInput\022\014\n\004tim"
    "e\030\001 \002(\r\022\031\n\005input\030\002 \002(\0132\n.net.Input\022\"\n\017im"
    "portant_moves\030\003 \003(\0132\t.net.Move\"\\\n\nPacket"
    "Sync\022\n\n\002id\030\001 \002(\r\022\014\n\004time\030\002 \002(\r\022\031\n\005state\030"
    "\003 \002(\0132\n.net.State\022\031\n\005input\030\004 \002(\0132\n.net.I"
    "nput*,\n\nPacketType\022\t\n\005SPAWN\020\001\022\t\n\005INPUT\020\002"
    "\022\010\n\004SYNC\020\003", 690);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "Net.proto", &protobuf_RegisterTypes);
  Input::default_instance_ = new Input();
  State::default_instance_ = new State();
  Move::default_instance_ = new Move();
  PacketBase::default_instance_ = new PacketBase();
  PacketSpawn::default_instance_ = new PacketSpawn();
  PacketInput::default_instance_ = new PacketInput();
  PacketSync::default_instance_ = new PacketSync();
  Input::default_instance_->InitAsDefaultInstance();
  State::default_instance_->InitAsDefaultInstance();
  Move::default_instance_->InitAsDefaultInstance();
  PacketBase::default_instance_->InitAsDefaultInstance();
  PacketSpawn::default_instance_->InitAsDefaultInstance();
  PacketInput::default_instance_->InitAsDefaultInstance();
  PacketSync::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_Net_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_Net_2eproto {
  StaticDescriptorInitializer_Net_2eproto() {
    protobuf_AddDesc_Net_2eproto();
  }
} static_descriptor_initializer_Net_2eproto_;
const ::google::protobuf::EnumDescriptor* PacketType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PacketType_descriptor_;
}
bool PacketType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int Input::kForwardFieldNumber;
const int Input::kLeftFieldNumber;
const int Input::kRightFieldNumber;
#endif  // !_MSC_VER

Input::Input()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:net.Input)
}

void Input::InitAsDefaultInstance() {
}

Input::Input(const Input& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:net.Input)
}

void Input::SharedCtor() {
  _cached_size_ = 0;
  forward_ = false;
  left_ = false;
  right_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Input::~Input() {
  // @@protoc_insertion_point(destructor:net.Input)
  SharedDtor();
}

void Input::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Input::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Input::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Input_descriptor_;
}

const Input& Input::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Net_2eproto();
  return *default_instance_;
}

Input* Input::default_instance_ = NULL;

Input* Input::New() const {
  return new Input;
}

void Input::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Input*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(forward_, right_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Input::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:net.Input)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool forward = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &forward_)));
          set_has_forward();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_left;
        break;
      }

      // required bool left = 2;
      case 2: {
        if (tag == 16) {
         parse_left:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &left_)));
          set_has_left();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_right;
        break;
      }

      // required bool right = 3;
      case 3: {
        if (tag == 24) {
         parse_right:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &right_)));
          set_has_right();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:net.Input)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:net.Input)
  return false;
#undef DO_
}

void Input::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:net.Input)
  // required bool forward = 1;
  if (has_forward()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->forward(), output);
  }

  // required bool left = 2;
  if (has_left()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->left(), output);
  }

  // required bool right = 3;
  if (has_right()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->right(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:net.Input)
}

::google::protobuf::uint8* Input::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:net.Input)
  // required bool forward = 1;
  if (has_forward()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->forward(), target);
  }

  // required bool left = 2;
  if (has_left()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->left(), target);
  }

  // required bool right = 3;
  if (has_right()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->right(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:net.Input)
  return target;
}

int Input::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool forward = 1;
    if (has_forward()) {
      total_size += 1 + 1;
    }

    // required bool left = 2;
    if (has_left()) {
      total_size += 1 + 1;
    }

    // required bool right = 3;
    if (has_right()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Input::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Input* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Input*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Input::MergeFrom(const Input& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_forward()) {
      set_forward(from.forward());
    }
    if (from.has_left()) {
      set_left(from.left());
    }
    if (from.has_right()) {
      set_right(from.right());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Input::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Input::CopyFrom(const Input& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Input::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void Input::Swap(Input* other) {
  if (other != this) {
    std::swap(forward_, other->forward_);
    std::swap(left_, other->left_);
    std::swap(right_, other->right_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Input::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Input_descriptor_;
  metadata.reflection = Input_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int State::kPositionXFieldNumber;
const int State::kPositionYFieldNumber;
const int State::kAngleFieldNumber;
const int State::kVelocityXFieldNumber;
const int State::kVelocityYFieldNumber;
const int State::kAngularVelocityFieldNumber;
const int State::kScaleFieldNumber;
const int State::kMassFieldNumber;
const int State::kInertiaTensorFieldNumber;
#endif  // !_MSC_VER

State::State()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:net.State)
}

void State::InitAsDefaultInstance() {
}

State::State(const State& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:net.State)
}

void State::SharedCtor() {
  _cached_size_ = 0;
  position_x_ = 0;
  position_y_ = 0;
  angle_ = 0;
  velocity_x_ = 0;
  velocity_y_ = 0;
  angular_velocity_ = 0;
  scale_ = 0;
  mass_ = 0;
  inertia_tensor_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

State::~State() {
  // @@protoc_insertion_point(destructor:net.State)
  SharedDtor();
}

void State::SharedDtor() {
  if (this != default_instance_) {
  }
}

void State::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* State::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return State_descriptor_;
}

const State& State::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Net_2eproto();
  return *default_instance_;
}

State* State::default_instance_ = NULL;

State* State::New() const {
  return new State;
}

void State::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<State*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(position_x_, mass_);
  }
  inertia_tensor_ = 0;

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool State::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:net.State)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float position_x = 1;
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &position_x_)));
          set_has_position_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_position_y;
        break;
      }

      // required float position_y = 2;
      case 2: {
        if (tag == 21) {
         parse_position_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &position_y_)));
          set_has_position_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_angle;
        break;
      }

      // required float angle = 3;
      case 3: {
        if (tag == 29) {
         parse_angle:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &angle_)));
          set_has_angle();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(61)) goto parse_velocity_x;
        break;
      }

      // required float velocity_x = 7;
      case 7: {
        if (tag == 61) {
         parse_velocity_x:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &velocity_x_)));
          set_has_velocity_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(69)) goto parse_velocity_y;
        break;
      }

      // required float velocity_y = 8;
      case 8: {
        if (tag == 69) {
         parse_velocity_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &velocity_y_)));
          set_has_velocity_y();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(77)) goto parse_angular_velocity;
        break;
      }

      // required float angular_velocity = 9;
      case 9: {
        if (tag == 77) {
         parse_angular_velocity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &angular_velocity_)));
          set_has_angular_velocity();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(85)) goto parse_scale;
        break;
      }

      // required float scale = 10;
      case 10: {
        if (tag == 85) {
         parse_scale:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &scale_)));
          set_has_scale();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(93)) goto parse_mass;
        break;
      }

      // required float mass = 11;
      case 11: {
        if (tag == 93) {
         parse_mass:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &mass_)));
          set_has_mass();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(101)) goto parse_inertia_tensor;
        break;
      }

      // required float inertia_tensor = 12;
      case 12: {
        if (tag == 101) {
         parse_inertia_tensor:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &inertia_tensor_)));
          set_has_inertia_tensor();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:net.State)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:net.State)
  return false;
#undef DO_
}

void State::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:net.State)
  // required float position_x = 1;
  if (has_position_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->position_x(), output);
  }

  // required float position_y = 2;
  if (has_position_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->position_y(), output);
  }

  // required float angle = 3;
  if (has_angle()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->angle(), output);
  }

  // required float velocity_x = 7;
  if (has_velocity_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->velocity_x(), output);
  }

  // required float velocity_y = 8;
  if (has_velocity_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(8, this->velocity_y(), output);
  }

  // required float angular_velocity = 9;
  if (has_angular_velocity()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(9, this->angular_velocity(), output);
  }

  // required float scale = 10;
  if (has_scale()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(10, this->scale(), output);
  }

  // required float mass = 11;
  if (has_mass()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(11, this->mass(), output);
  }

  // required float inertia_tensor = 12;
  if (has_inertia_tensor()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(12, this->inertia_tensor(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:net.State)
}

::google::protobuf::uint8* State::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:net.State)
  // required float position_x = 1;
  if (has_position_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->position_x(), target);
  }

  // required float position_y = 2;
  if (has_position_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->position_y(), target);
  }

  // required float angle = 3;
  if (has_angle()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->angle(), target);
  }

  // required float velocity_x = 7;
  if (has_velocity_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(7, this->velocity_x(), target);
  }

  // required float velocity_y = 8;
  if (has_velocity_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(8, this->velocity_y(), target);
  }

  // required float angular_velocity = 9;
  if (has_angular_velocity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(9, this->angular_velocity(), target);
  }

  // required float scale = 10;
  if (has_scale()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(10, this->scale(), target);
  }

  // required float mass = 11;
  if (has_mass()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(11, this->mass(), target);
  }

  // required float inertia_tensor = 12;
  if (has_inertia_tensor()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(12, this->inertia_tensor(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:net.State)
  return target;
}

int State::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float position_x = 1;
    if (has_position_x()) {
      total_size += 1 + 4;
    }

    // required float position_y = 2;
    if (has_position_y()) {
      total_size += 1 + 4;
    }

    // required float angle = 3;
    if (has_angle()) {
      total_size += 1 + 4;
    }

    // required float velocity_x = 7;
    if (has_velocity_x()) {
      total_size += 1 + 4;
    }

    // required float velocity_y = 8;
    if (has_velocity_y()) {
      total_size += 1 + 4;
    }

    // required float angular_velocity = 9;
    if (has_angular_velocity()) {
      total_size += 1 + 4;
    }

    // required float scale = 10;
    if (has_scale()) {
      total_size += 1 + 4;
    }

    // required float mass = 11;
    if (has_mass()) {
      total_size += 1 + 4;
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // required float inertia_tensor = 12;
    if (has_inertia_tensor()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void State::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const State* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const State*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void State::MergeFrom(const State& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_position_x()) {
      set_position_x(from.position_x());
    }
    if (from.has_position_y()) {
      set_position_y(from.position_y());
    }
    if (from.has_angle()) {
      set_angle(from.angle());
    }
    if (from.has_velocity_x()) {
      set_velocity_x(from.velocity_x());
    }
    if (from.has_velocity_y()) {
      set_velocity_y(from.velocity_y());
    }
    if (from.has_angular_velocity()) {
      set_angular_velocity(from.angular_velocity());
    }
    if (from.has_scale()) {
      set_scale(from.scale());
    }
    if (from.has_mass()) {
      set_mass(from.mass());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_inertia_tensor()) {
      set_inertia_tensor(from.inertia_tensor());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void State::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void State::CopyFrom(const State& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool State::IsInitialized() const {
  if ((_has_bits_[0] & 0x000001ff) != 0x000001ff) return false;

  return true;
}

void State::Swap(State* other) {
  if (other != this) {
    std::swap(position_x_, other->position_x_);
    std::swap(position_y_, other->position_y_);
    std::swap(angle_, other->angle_);
    std::swap(velocity_x_, other->velocity_x_);
    std::swap(velocity_y_, other->velocity_y_);
    std::swap(angular_velocity_, other->angular_velocity_);
    std::swap(scale_, other->scale_);
    std::swap(mass_, other->mass_);
    std::swap(inertia_tensor_, other->inertia_tensor_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata State::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = State_descriptor_;
  metadata.reflection = State_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Move::kTimeFieldNumber;
const int Move::kInputFieldNumber;
const int Move::kStateFieldNumber;
#endif  // !_MSC_VER

Move::Move()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:net.Move)
}

void Move::InitAsDefaultInstance() {
  input_ = const_cast< ::net::Input*>(&::net::Input::default_instance());
  state_ = const_cast< ::net::State*>(&::net::State::default_instance());
}

Move::Move(const Move& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:net.Move)
}

void Move::SharedCtor() {
  _cached_size_ = 0;
  time_ = 0u;
  input_ = NULL;
  state_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Move::~Move() {
  // @@protoc_insertion_point(destructor:net.Move)
  SharedDtor();
}

void Move::SharedDtor() {
  if (this != default_instance_) {
    delete input_;
    delete state_;
  }
}

void Move::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Move::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Move_descriptor_;
}

const Move& Move::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Net_2eproto();
  return *default_instance_;
}

Move* Move::default_instance_ = NULL;

Move* Move::New() const {
  return new Move;
}

void Move::Clear() {
  if (_has_bits_[0 / 32] & 7) {
    time_ = 0u;
    if (has_input()) {
      if (input_ != NULL) input_->::net::Input::Clear();
    }
    if (has_state()) {
      if (state_ != NULL) state_->::net::State::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Move::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:net.Move)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 time = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &time_)));
          set_has_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_input;
        break;
      }

      // required .net.Input input = 2;
      case 2: {
        if (tag == 18) {
         parse_input:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_input()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_state;
        break;
      }

      // required .net.State state = 3;
      case 3: {
        if (tag == 26) {
         parse_state:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_state()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:net.Move)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:net.Move)
  return false;
#undef DO_
}

void Move::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:net.Move)
  // required uint32 time = 1;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->time(), output);
  }

  // required .net.Input input = 2;
  if (has_input()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->input(), output);
  }

  // required .net.State state = 3;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->state(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:net.Move)
}

::google::protobuf::uint8* Move::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:net.Move)
  // required uint32 time = 1;
  if (has_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->time(), target);
  }

  // required .net.Input input = 2;
  if (has_input()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->input(), target);
  }

  // required .net.State state = 3;
  if (has_state()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->state(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:net.Move)
  return target;
}

int Move::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 time = 1;
    if (has_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->time());
    }

    // required .net.Input input = 2;
    if (has_input()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->input());
    }

    // required .net.State state = 3;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->state());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Move::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Move* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Move*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Move::MergeFrom(const Move& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_time()) {
      set_time(from.time());
    }
    if (from.has_input()) {
      mutable_input()->::net::Input::MergeFrom(from.input());
    }
    if (from.has_state()) {
      mutable_state()->::net::State::MergeFrom(from.state());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Move::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Move::CopyFrom(const Move& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Move::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  if (has_input()) {
    if (!this->input().IsInitialized()) return false;
  }
  if (has_state()) {
    if (!this->state().IsInitialized()) return false;
  }
  return true;
}

void Move::Swap(Move* other) {
  if (other != this) {
    std::swap(time_, other->time_);
    std::swap(input_, other->input_);
    std::swap(state_, other->state_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Move::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Move_descriptor_;
  metadata.reflection = Move_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PacketBase::kTypeFieldNumber;
const int PacketBase::kDataFieldNumber;
#endif  // !_MSC_VER

PacketBase::PacketBase()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:net.PacketBase)
}

void PacketBase::InitAsDefaultInstance() {
}

PacketBase::PacketBase(const PacketBase& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:net.PacketBase)
}

void PacketBase::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  type_ = 1;
  data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PacketBase::~PacketBase() {
  // @@protoc_insertion_point(destructor:net.PacketBase)
  SharedDtor();
}

void PacketBase::SharedDtor() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (this != default_instance_) {
  }
}

void PacketBase::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PacketBase::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PacketBase_descriptor_;
}

const PacketBase& PacketBase::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Net_2eproto();
  return *default_instance_;
}

PacketBase* PacketBase::default_instance_ = NULL;

PacketBase* PacketBase::New() const {
  return new PacketBase;
}

void PacketBase::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    type_ = 1;
    if (has_data()) {
      if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
        data_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PacketBase::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:net.PacketBase)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .net.PacketType type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::net::PacketType_IsValid(value)) {
            set_type(static_cast< ::net::PacketType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_data;
        break;
      }

      // required bytes data = 2;
      case 2: {
        if (tag == 18) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:net.PacketBase)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:net.PacketBase)
  return false;
#undef DO_
}

void PacketBase::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:net.PacketBase)
  // required .net.PacketType type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // required bytes data = 2;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->data(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:net.PacketBase)
}

::google::protobuf::uint8* PacketBase::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:net.PacketBase)
  // required .net.PacketType type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // required bytes data = 2;
  if (has_data()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->data(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:net.PacketBase)
  return target;
}

int PacketBase::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .net.PacketType type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // required bytes data = 2;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PacketBase::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PacketBase* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PacketBase*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PacketBase::MergeFrom(const PacketBase& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_data()) {
      set_data(from.data());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PacketBase::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PacketBase::CopyFrom(const PacketBase& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PacketBase::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void PacketBase::Swap(PacketBase* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(data_, other->data_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PacketBase::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PacketBase_descriptor_;
  metadata.reflection = PacketBase_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PacketSpawn::kIdFieldNumber;
const int PacketSpawn::kTimeFieldNumber;
const int PacketSpawn::kStateFieldNumber;
#endif  // !_MSC_VER

PacketSpawn::PacketSpawn()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:net.PacketSpawn)
}

void PacketSpawn::InitAsDefaultInstance() {
  state_ = const_cast< ::net::State*>(&::net::State::default_instance());
}

PacketSpawn::PacketSpawn(const PacketSpawn& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:net.PacketSpawn)
}

void PacketSpawn::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  time_ = 0u;
  state_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PacketSpawn::~PacketSpawn() {
  // @@protoc_insertion_point(destructor:net.PacketSpawn)
  SharedDtor();
}

void PacketSpawn::SharedDtor() {
  if (this != default_instance_) {
    delete state_;
  }
}

void PacketSpawn::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PacketSpawn::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PacketSpawn_descriptor_;
}

const PacketSpawn& PacketSpawn::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Net_2eproto();
  return *default_instance_;
}

PacketSpawn* PacketSpawn::default_instance_ = NULL;

PacketSpawn* PacketSpawn::New() const {
  return new PacketSpawn;
}

void PacketSpawn::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<PacketSpawn*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 7) {
    ZR_(id_, time_);
    if (has_state()) {
      if (state_ != NULL) state_->::net::State::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PacketSpawn::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:net.PacketSpawn)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_time;
        break;
      }

      // required uint32 time = 2;
      case 2: {
        if (tag == 16) {
         parse_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &time_)));
          set_has_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_state;
        break;
      }

      // required .net.State state = 3;
      case 3: {
        if (tag == 26) {
         parse_state:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_state()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:net.PacketSpawn)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:net.PacketSpawn)
  return false;
#undef DO_
}

void PacketSpawn::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:net.PacketSpawn)
  // required uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // required uint32 time = 2;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->time(), output);
  }

  // required .net.State state = 3;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->state(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:net.PacketSpawn)
}

::google::protobuf::uint8* PacketSpawn::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:net.PacketSpawn)
  // required uint32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->id(), target);
  }

  // required uint32 time = 2;
  if (has_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->time(), target);
  }

  // required .net.State state = 3;
  if (has_state()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->state(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:net.PacketSpawn)
  return target;
}

int PacketSpawn::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // required uint32 time = 2;
    if (has_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->time());
    }

    // required .net.State state = 3;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->state());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PacketSpawn::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PacketSpawn* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PacketSpawn*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PacketSpawn::MergeFrom(const PacketSpawn& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_time()) {
      set_time(from.time());
    }
    if (from.has_state()) {
      mutable_state()->::net::State::MergeFrom(from.state());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PacketSpawn::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PacketSpawn::CopyFrom(const PacketSpawn& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PacketSpawn::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  if (has_state()) {
    if (!this->state().IsInitialized()) return false;
  }
  return true;
}

void PacketSpawn::Swap(PacketSpawn* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(time_, other->time_);
    std::swap(state_, other->state_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PacketSpawn::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PacketSpawn_descriptor_;
  metadata.reflection = PacketSpawn_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PacketInput::kTimeFieldNumber;
const int PacketInput::kInputFieldNumber;
const int PacketInput::kImportantMovesFieldNumber;
#endif  // !_MSC_VER

PacketInput::PacketInput()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:net.PacketInput)
}

void PacketInput::InitAsDefaultInstance() {
  input_ = const_cast< ::net::Input*>(&::net::Input::default_instance());
}

PacketInput::PacketInput(const PacketInput& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:net.PacketInput)
}

void PacketInput::SharedCtor() {
  _cached_size_ = 0;
  time_ = 0u;
  input_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PacketInput::~PacketInput() {
  // @@protoc_insertion_point(destructor:net.PacketInput)
  SharedDtor();
}

void PacketInput::SharedDtor() {
  if (this != default_instance_) {
    delete input_;
  }
}

void PacketInput::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PacketInput::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PacketInput_descriptor_;
}

const PacketInput& PacketInput::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Net_2eproto();
  return *default_instance_;
}

PacketInput* PacketInput::default_instance_ = NULL;

PacketInput* PacketInput::New() const {
  return new PacketInput;
}

void PacketInput::Clear() {
  if (_has_bits_[0 / 32] & 3) {
    time_ = 0u;
    if (has_input()) {
      if (input_ != NULL) input_->::net::Input::Clear();
    }
  }
  important_moves_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PacketInput::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:net.PacketInput)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 time = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &time_)));
          set_has_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_input;
        break;
      }

      // required .net.Input input = 2;
      case 2: {
        if (tag == 18) {
         parse_input:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_input()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_important_moves;
        break;
      }

      // repeated .net.Move important_moves = 3;
      case 3: {
        if (tag == 26) {
         parse_important_moves:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_important_moves()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_important_moves;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:net.PacketInput)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:net.PacketInput)
  return false;
#undef DO_
}

void PacketInput::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:net.PacketInput)
  // required uint32 time = 1;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->time(), output);
  }

  // required .net.Input input = 2;
  if (has_input()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->input(), output);
  }

  // repeated .net.Move important_moves = 3;
  for (int i = 0; i < this->important_moves_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->important_moves(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:net.PacketInput)
}

::google::protobuf::uint8* PacketInput::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:net.PacketInput)
  // required uint32 time = 1;
  if (has_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->time(), target);
  }

  // required .net.Input input = 2;
  if (has_input()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->input(), target);
  }

  // repeated .net.Move important_moves = 3;
  for (int i = 0; i < this->important_moves_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->important_moves(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:net.PacketInput)
  return target;
}

int PacketInput::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 time = 1;
    if (has_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->time());
    }

    // required .net.Input input = 2;
    if (has_input()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->input());
    }

  }
  // repeated .net.Move important_moves = 3;
  total_size += 1 * this->important_moves_size();
  for (int i = 0; i < this->important_moves_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->important_moves(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PacketInput::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PacketInput* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PacketInput*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PacketInput::MergeFrom(const PacketInput& from) {
  GOOGLE_CHECK_NE(&from, this);
  important_moves_.MergeFrom(from.important_moves_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_time()) {
      set_time(from.time());
    }
    if (from.has_input()) {
      mutable_input()->::net::Input::MergeFrom(from.input());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PacketInput::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PacketInput::CopyFrom(const PacketInput& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PacketInput::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_input()) {
    if (!this->input().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->important_moves())) return false;
  return true;
}

void PacketInput::Swap(PacketInput* other) {
  if (other != this) {
    std::swap(time_, other->time_);
    std::swap(input_, other->input_);
    important_moves_.Swap(&other->important_moves_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PacketInput::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PacketInput_descriptor_;
  metadata.reflection = PacketInput_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PacketSync::kIdFieldNumber;
const int PacketSync::kTimeFieldNumber;
const int PacketSync::kStateFieldNumber;
const int PacketSync::kInputFieldNumber;
#endif  // !_MSC_VER

PacketSync::PacketSync()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:net.PacketSync)
}

void PacketSync::InitAsDefaultInstance() {
  state_ = const_cast< ::net::State*>(&::net::State::default_instance());
  input_ = const_cast< ::net::Input*>(&::net::Input::default_instance());
}

PacketSync::PacketSync(const PacketSync& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:net.PacketSync)
}

void PacketSync::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0u;
  time_ = 0u;
  state_ = NULL;
  input_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PacketSync::~PacketSync() {
  // @@protoc_insertion_point(destructor:net.PacketSync)
  SharedDtor();
}

void PacketSync::SharedDtor() {
  if (this != default_instance_) {
    delete state_;
    delete input_;
  }
}

void PacketSync::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PacketSync::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PacketSync_descriptor_;
}

const PacketSync& PacketSync::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_Net_2eproto();
  return *default_instance_;
}

PacketSync* PacketSync::default_instance_ = NULL;

PacketSync* PacketSync::New() const {
  return new PacketSync;
}

void PacketSync::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<PacketSync*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 15) {
    ZR_(id_, time_);
    if (has_state()) {
      if (state_ != NULL) state_->::net::State::Clear();
    }
    if (has_input()) {
      if (input_ != NULL) input_->::net::Input::Clear();
    }
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PacketSync::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:net.PacketSync)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_time;
        break;
      }

      // required uint32 time = 2;
      case 2: {
        if (tag == 16) {
         parse_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &time_)));
          set_has_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_state;
        break;
      }

      // required .net.State state = 3;
      case 3: {
        if (tag == 26) {
         parse_state:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_state()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_input;
        break;
      }

      // required .net.Input input = 4;
      case 4: {
        if (tag == 34) {
         parse_input:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_input()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:net.PacketSync)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:net.PacketSync)
  return false;
#undef DO_
}

void PacketSync::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:net.PacketSync)
  // required uint32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->id(), output);
  }

  // required uint32 time = 2;
  if (has_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->time(), output);
  }

  // required .net.State state = 3;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->state(), output);
  }

  // required .net.Input input = 4;
  if (has_input()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->input(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:net.PacketSync)
}

::google::protobuf::uint8* PacketSync::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:net.PacketSync)
  // required uint32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->id(), target);
  }

  // required uint32 time = 2;
  if (has_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->time(), target);
  }

  // required .net.State state = 3;
  if (has_state()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->state(), target);
  }

  // required .net.Input input = 4;
  if (has_input()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->input(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:net.PacketSync)
  return target;
}

int PacketSync::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->id());
    }

    // required uint32 time = 2;
    if (has_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->time());
    }

    // required .net.State state = 3;
    if (has_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->state());
    }

    // required .net.Input input = 4;
    if (has_input()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->input());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PacketSync::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PacketSync* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PacketSync*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PacketSync::MergeFrom(const PacketSync& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_time()) {
      set_time(from.time());
    }
    if (from.has_state()) {
      mutable_state()->::net::State::MergeFrom(from.state());
    }
    if (from.has_input()) {
      mutable_input()->::net::Input::MergeFrom(from.input());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PacketSync::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PacketSync::CopyFrom(const PacketSync& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PacketSync::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  if (has_state()) {
    if (!this->state().IsInitialized()) return false;
  }
  if (has_input()) {
    if (!this->input().IsInitialized()) return false;
  }
  return true;
}

void PacketSync::Swap(PacketSync* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(time_, other->time_);
    std::swap(state_, other->state_);
    std::swap(input_, other->input_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PacketSync::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PacketSync_descriptor_;
  metadata.reflection = PacketSync_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace net

// @@protoc_insertion_point(global_scope)
